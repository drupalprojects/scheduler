<?php
// $Id$

/**
 * Implementation of hook_help().
 */
function scheduler_help($section) {
  if ($section == 'admin/modules#description') {
    return t('A module to schedule when nodes are (un)published.');
  }
}


/**
 * Implementation of hook_perm().
 */
function scheduler_perm() {
  return array('schedule (un)publishing of nodes');
}


/**
 * Implementation of hook_form_alter().
 */
function scheduler_form_alter($form_id, &$form) {
  //allow scheduling on a per-node-type basis
  if (isset($form['type']) && $form['type']['#value'] .'_node_settings' == $form_id) {
    $form['workflow']['scheduler_'. $form['type']['#value']] = array(
      '#type' => 'checkbox', 
      '#title' => t('Enable scheduled (un)publishing'), 
      '#default_value' => variable_get('scheduler_'. $form['type']['#value'], 0),
      '#description' => t('Check this box to enable scheduled (un)publishing for this node type.')
    );
  }
 
  else if (isset($form['type']) && $form['type']['#value'] .'_node_form' == $form_id) {
    if (user_access('schedule (un)publishing of nodes')) {
      // if scheduling has been enabled for this node type
      if (variable_get('scheduler_'. $form['type']['#value'], 0) == 1) {
        
        //use JScalendar picker for dates if the module exists and is enabled
        $jscalendar = FALSE;
        if (module_exist('jscalendar')) {
          $jscalendar = TRUE;
          // Show 24-hour clock for JScalendar
          $form['#jscalendar_timeFormat'] = '24';
        }
        
        $node = $form['#node'];
        
        //only load the values if we are viewing an existing node
        if ($node->nid > 0) {
          $defaults = db_fetch_object(db_query('SELECT publish_on, unpublish_on, timezone FROM {scheduler} WHERE nid = %d', $node->nid));
        }
        
        //note don't use format_date() because drupal automatically formats the date to the user's timezone
        //this will show the wrong time because scheduler can set nodes to be published in different timezones
        $form['scheduler_settings'] = array(
          '#type' => 'fieldset',
          '#title' => t('Scheduling options'),
          '#collapsible' => TRUE,
          '#collapsed' => ($defaults->publish_on != 0 || $defaults->unpublish_on != 0) ? FALSE: TRUE,
          '#weight' => 35
        );
        
        $form['scheduler_settings']['publish_on'] = array(
          '#type' => 'textfield', 
          '#title' => t('Publish on'), 
          '#maxlength' => 25,
          //we subtract the time zone to show the user the correct time they entered
          //and below that we show the timezone to adjust this time by
          //we store the adjusted timezone value in the database for cron
          '#default_value' => $defaults->publish_on ? date('Y-m-d H:i:s', $defaults->publish_on - $defaults->timezone) : '',
          '#description' => t('Format: %time. Leave blank to publish on the time of form submission.', array('%time' => date('Y-m-d H:i:s'))),
          '#attributes' => $jscalendar ? array('class' => 'jscalendar') : array()
        );
        
        $form['scheduler_settings']['unpublish_on'] = array(
          '#type' => 'textfield', 
          '#title' => t('Unpublish on'), 
          '#maxlength' => 25, 
          //we subtract the time zone to show the user the correct time they entered
          //and below that we show the timezone to adjust this time by
          //we store the adjusted timezone value in the database for cron
          '#default_value' => $defaults->unpublish_on ? date('Y-m-d H:i:s', $defaults->unpublish_on - $defaults->timezone) : '',
          '#description' => t('Format: %time. Leave blank to not unpublish this node.', array('%time' => date('Y-m-d H:i:s'))),
          '#attributes' => $jscalendar ? array('class' => 'jscalendar') : array()
        );
        
        //default to user timezone, if not specified, default to system wide timezone
        global $user;
        $zones = _system_zonelist();
        $form['scheduler_settings']['timezone'] = array(
          '#type' => 'select', 
          '#title' => t('Time zone'), 
          '#default_value' => $defaults->timezone ? $defaults->timezone : (strlen($user->timezone) ? $user->timezone : variable_get('date_default_timezone', 0)),
          '#options' => $zones, 
          '#description' => t('Select the time zone to (un)publish in.')
        );
      }    
    } 
  }
}


/**
 * Implementation of hook_nodeapi().
 */
function scheduler_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {
  if (user_access('schedule (un)publishing of nodes')) {
    switch ($op) {
      case 'submit':
        // right before we save the node, we need to check if a "publish on" value has been set
        // if it has been set, we want to make sure the node is unpublished
        // since it will be published at a later date
        if ($node->publish_on != '') {
          $node->status = 0;
        }
      
        //adjust the entered times for timezone consideration
        $node->publish_on = $node->publish_on ? strtotime($node->publish_on) + $node->timezone : NULL;
        $node->unpublish_on = $node->unpublish_on ? strtotime($node->unpublish_on) + $node->timezone : NULL;

        break;
      
      case 'insert':
        //only insert into database if we need to (un)publish this node at some date
        if ($node->publish_on != NULL || $node->unpublish_on != NULL) {
          db_query('INSERT INTO {scheduler} (nid, publish_on, unpublish_on, timezone) VALUES (%d, %d, %d, %d)', $node->nid, $node->publish_on, $node->unpublish_on, $node->timezone);
        }
        break;

      case 'update':
        $exists = db_result(db_query('SELECT nid FROM {scheduler} WHERE nid = %d', $node->nid));
          
        //if this node has already been scheduled, update its record
        if ($exists) {
          //only update database if we need to (un)publish this node at some date
          //otherwise the user probably cleared out the (un)publish dates so we should remove the record
          if ($node->publish_on != NULL || $node->unpublish_on != NULL) {
            db_query('UPDATE {scheduler} SET publish_on = %d, unpublish_on = %d, timezone = %d WHERE nid = %d', $node->publish_on, $node->unpublish_on, $node->timezone, $node->nid);
          }
          else {
            db_query('DELETE FROM {scheduler} WHERE nid = %d', $node->nid);
          }
        }
        //node doesn't exist, create a record only if the (un)publish fields are blank
        else if ($node->publish_on != NULL || $node->unpublish_on != NULL) {
          db_query('INSERT INTO {scheduler} (nid, publish_on, unpublish_on, timezone) VALUES (%d, %d, %d, %d)', $node->nid, $node->publish_on, $node->unpublish_on, $node->timezone);
        }
        break;
  
      case 'delete':
        db_query('DELETE FROM {scheduler} WHERE nid = %d', $node->nid);
        break;
    }
  }
}


/**
 * Implementation of hook_cron().
 */
function scheduler_cron() {
  $clear_cache = FALSE;
  
  //if the time now is greater than the time to publish a node, publish it
  $nodes = db_query('SELECT * FROM {scheduler} s LEFT JOIN {node} n ON s.nid = n.nid WHERE n.status = 0 AND s.publish_on > 0 AND s.publish_on < %d + s.timezone', time());
  
  while ($node = db_fetch_object($nodes)) {
    db_query('UPDATE {node} SET created = %d, changed = %d, status = 1 WHERE nid = %d', $node->publish_on, $node->publish_on, $node->nid);
    
    //if this node is not to be unpublished, then we can delete the record
    if ($node->unpublish_on == 0) {
      db_query('DELETE FROM {scheduler} WHERE nid = %d', $node->nid);
    }
    //we need to unpublish this node at some time so clear the publish on since it's been published
    else {
      db_query('UPDATE {scheduler} SET publish_on = 0 WHERE nid = %d', $node->nid);
    }
    
    //invoke scheduler API
    _scheduler_scheduler_api($node, 'publish');
    
    watchdog('content', t('%type: scheduled publishing of %title.', array('%type' => theme('placeholder', t($node->type)), '%title' => theme('placeholder', $node->title))), WATCHDOG_NOTICE, l(t('view'), 'node/'. $node->nid));
    $clear_cache = TRUE;
  }
  
  //if the time is greater than the time to unpublish a node, unpublish it
  $nodes = db_query('SELECT * FROM {scheduler} s LEFT JOIN {node} n ON s.nid = n.nid WHERE n.status = 1 AND s.unpublish_on > 0 AND s.unpublish_on < %d + s.timezone', time());
  
  while ($node = db_fetch_object($nodes)) {
    //if this node is to be unpublished, we can update the node and remove the record since it can't be republished
    db_query('UPDATE {node} SET status = 0, changed = %d WHERE nid = %d', $node->unpublish_on, $node->nid);
    db_query('DELETE FROM {scheduler} WHERE nid = %d', $node->nid);
    
    //invoke scheduler API
    _scheduler_scheduler_api($node, 'unpublish');
    
    watchdog('content', t('%type: scheduled unpublishing of %title.', array('%type' => theme('placeholder', t($node->type)), '%title' => theme('placeholder', $node->title))), WATCHDOG_NOTICE, l(t('view'), 'node/'. $node->nid));
    $clear_cache = TRUE;
  }
  
  if ($clear_cache) {
    // clear the cache so an anonymous poster can see the node being published or unpublished
    cache_clear_all();
  }
}


/**
 * Scheduler API to perform actions when nodes are (un)published
 *
 * @param $node
 *  The node object
 * @param $action
 *  The action being performed, either "publish" or "unpublish"
 */
function _scheduler_scheduler_api($node, $action) {
  foreach (module_implements('scheduler_api') as $module) {
    $function = $module .'_scheduler_api';
    $function($node, $action); 
  }
}
